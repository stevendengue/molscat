      INTEGER FUNCTION IDPCHK(NQ, MXLAM, LAMBDA)
C  This subroutine is part of the MOLSCAT, BOUND and FIELD suite of programs
C
C  G. C. McBane, 5 OCT 2018
C
C  IDENTIFY DUPLICATE COLUMNS IN 2D INTEGER ARRAY WITH O(N LOG N)
C  ALGORITHM BASED ON NESTED SORTS.
C  SORT ON ELEMENTS OF EACH ROW, CARRYING ALONG POINTERS TO COLUMNS.
C  AFTER EACH SORT, SCAN THROUGH EACH 'CLUSTER' THAT HAD IDENTICAL ENTRIES
C  SO FAR, AND IDENTIFY NEW CLUSTERS OF VALUES THAT REMAIN UNRESOLVED.
C  SORT THOSE CLUSTERS ON ENTRIES FROM THE NEXT ROW.  IF ANY COLUMNS
C  STILL HAVE IDENTICAL VALUES EVEN AFTER THE LAST ROW HAS BEEN SORTED,
C  THOSE ARE DUPLICATES.
C  REQUIRES 3 TEMPORARY INTEGER ARRAYS OF LENGTH MXLAM.
C  USES ISORT QUICKSORT ROUTINE FROM SLATEC.
      IMPLICIT NONE
      INTEGER NQ, MXLAM, LAMBDA(NQ,MXLAM)
C  X CONTAINS DATA FROM LAMBDA USED AS A SORT KEY.
C  Y CONTAINS POINTERS TO COLUMNS OF LAMBDA.
C  AT THE END OF EACH PASS, EACH RUNLST ENTRY CONTAINS:
C    1 IF THE COLUMN POINTED TO BY THE CORRESPONDING ELEMENT OF Y IS ALREADY
C         KNOWN TO BE UNIQUE;
C    THE CLUSTER LENGTH IF IT IS THE FIRST MEMBER OF A STILL-DEGENERATE
C         CLUSTER; OR
C    0 IF IT IS A SUBSEQUENT MEMBER OF A STILL-DEGENERATE CLUSTER.
      INTEGER, ALLOCATABLE :: X(:), Y(:), RUNLST(:)
      INTEGER  I, J, RUNPOS, RUNLEN, NEWPOS, IFAIL

      INTEGER KFLAG      ! MODE FLAG FOR SORT ROUTINE
      PARAMETER(KFLAG=2) ! SORT X IN ASCENDING ORDER, CARRYING Y ALONG

      ALLOCATE(X(MXLAM), Y(MXLAM), RUNLST(MXLAM), STAT=IFAIL)
      IF (IFAIL.NE.0) THEN
        WRITE(6,*) ' TEMPORARY ARRAY ALLOCATION FAILURE IN IDPCHK'
        WRITE(6,*) ' IFAIL = ', IFAIL
        WRITE(6,*) ' TERMINATING.'
        STOP
      ENDIF

      DO I = 1, MXLAM
        Y(I) = I
        RUNLST(I) = 0
      ENDDO
      RUNLST(1) = MXLAM ! FIRST TIME THROUGH, TREAT AS ONE LONG CLUSTER

      DO I = 1, NQ       ! SCAN OVER ROWS
C  SCAN THROUGH EACH OLD CLUSTER, SORTING WHEN NEEDED
C  (WILL DO FULL SORT ON FIRST ROW WHEN I=1)
        RUNPOS = 1
        DO WHILE (RUNPOS.LT.MXLAM)
          RUNLEN = RUNLST(RUNPOS)
          IF (RUNLEN.GT.1) THEN
C  HAD A DEGENERACY; SORT CLUSTER ON NEW ROW DATA
C                    FILL X ARRAY SECTION WITH ELEMENTS FROM THIS ROW OF LAMBDA
            DO J =RUNPOS, RUNPOS+RUNLEN-1
              X(J) = LAMBDA(I,Y(J))
            ENDDO
C
C  IDENTIFY NEW CLUSTERS WITHIN THIS ONE
            CALL ISORT(X(RUNPOS),Y(RUNPOS),RUNLEN,KFLAG)
            NEWPOS = RUNPOS  ! FIRST NEW CLUSTER STARTS HERE AT BEGINNING
                             ! OF OLD
            RUNLST(RUNPOS)=1 ! WITH A SINGLE ELEMENT
            DO J = RUNPOS+1, RUNPOS+RUNLEN-1
C  LOOK AT REMAINING ELEMENTS OF OLD CLUSTER
              IF (X(J).EQ.X(J-1)) THEN
C  SAME AS PREVIOUS ELEMENT; NEW CLUSTER CONTINUES
C  - INCREMENT CLUSTER LENGTH
                RUNLST(NEWPOS) = RUNLST(NEWPOS)+1
C  - MARK THIS AS SUBSEQUENT MEMBER OF CLUSTER
                RUNLST(J) = 0
              ELSE
C  DIFFERENT FROM PREVIOUS ELEMENT; NEW CLUSTER BEGINS AT THIS POSITION
                NEWPOS = J
                RUNLST(J) = 1 ! WITH ONE ELEMENT SO FAR
              ENDIF
            ENDDO
C  DONE EXAMINING THIS OLD CLUSTER
          ENDIF
C  MOVE TO NEXT OLD CLUSTER
          RUNPOS = RUNPOS+RUNLEN
        ENDDO

      ENDDO

C  COUNT AND DISPLAY ANY REMAINING CLUSTERS, RETURNING COUNT TO CALLER
      IDPCHK = 0
      DO I = 1, MXLAM
        IF (RUNLST(I).GT.1) THEN
          WRITE(6,*) 'IDPCHK: DUPLICATE ENTRIES ',
     1               (Y(J), J = I, I+RUNLST(I)-1)
          IDPCHK = IDPCHK+1
        ENDIF
      ENDDO

      DEALLOCATE(X,Y,RUNLST)
      RETURN
      END
C ========================================================== END OF IDPCHK
      SUBROUTINE ISORT (IX, IY, N, KFLAG)
C  This subroutine is part of the MOLSCAT, BOUND and FIELD suite of programs
C
C  THE ISORT ROUTINE WAS TAKEN FROM THE SLATEC LIBRARY
C  AVAILABLE AT NETLIB.  ITS ERROR-HANDLING CODE WAS
C  MODIFIED TO REMOVE CALLS TO THE SLATEC ERROR ROUTINES
C  BUT IT IS OTHERWISE STOCK.

*DECK ISORT
C***BEGIN PROLOGUE  ISORT
C***PURPOSE  SORT AN ARRAY AND OPTIONALLY MAKE THE SAME INTERCHANGES IN
C            AN AUXILIARY ARRAY.  THE ARRAY MAY BE SORTED IN INCREASING
C            OR DECREASING ORDER.  A SLIGHTLY MODIFIED QUICKSORT
C            ALGORITHM IS USED.
C***LIBRARY   SLATEC
C***CATEGORY  N6A2A
C***TYPE      INTEGER (SSORT-S, DSORT-D, ISORT-I)
C***KEYWORDS  SINGLETON QUICKSORT, SORT, SORTING
C***AUTHOR  JONES, R. E., (SNLA)
C           KAHANER, D. K., (NBS)
C           WISNIEWSKI, J. A., (SNLA)
C***DESCRIPTION
C
C  ISORT SORTS ARRAY IX AND OPTIONALLY MAKES THE SAME INTERCHANGES IN
C  ARRAY IY.  THE ARRAY IX MAY BE SORTED IN INCREASING ORDER OR
C  DECREASING ORDER.  A SLIGHTLY MODIFIED QUICKSORT ALGORITHM IS USED.
C
C  DESCRIPTION OF PARAMETERS
C    IX - INTEGER ARRAY OF VALUES TO BE SORTED
C    IY - INTEGER ARRAY TO BE (OPTIONALLY) CARRIED ALONG
C    N  - NUMBER OF VALUES IN INTEGER ARRAY IX TO BE SORTED
C    KFLAG - CONTROL PARAMETER
C          =  2  MEANS SORT IX IN INCREASING ORDER AND CARRY IY ALONG.
C          =  1  MEANS SORT IX IN INCREASING ORDER (IGNORING IY)
C          = -1  MEANS SORT IX IN DECREASING ORDER (IGNORING IY)
C          = -2  MEANS SORT IX IN DECREASING ORDER AND CARRY IY ALONG.
C
C***REFERENCES  R. C. SINGLETON, ALGORITHM 347, AN EFFICIENT ALGORITHM
C               FOR SORTING WITH MINIMAL STORAGE, COMMUNICATIONS OF
C               THE ACM, 12, 3 (1969), PP. 185-187.
C***ROUTINES CALLED  XERMSG
C***REVISION HISTORY  (YYMMDD)
C   761118  DATE WRITTEN
C   810801  MODIFIED BY DAVID K. KAHANER.
C   890531  CHANGED ALL SPECIFIC INTRINSICS TO GENERIC.  (WRB)
C   890831  MODIFIED ARRAY DECLARATIONS.  (WRB)
C   891009  REMOVED UNREFERENCED STATEMENT LABELS.  (WRB)
C   891009  REVISION DATE FROM VERSION 3.2
C   891214  PROLOGUE CONVERTED TO VERSION 4.0 FORMAT.  (BAB)
C   900315  CALLS TO XERROR CHANGED TO CALLS TO XERMSG.  (THJ)
C   901012  DECLARED ALL VARIABLES; CHANGED X,Y TO IX,IY. (M. MCCLAIN)
C   920501  REFORMATTED THE REFERENCES SECTION.  (DWL, WRB)
C   920519  CLARIFIED ERROR MESSAGES.  (DWL)
C   920801  DECLARATIONS SECTION REBUILT AND CODE RESTRUCTURED TO USE
C           IF-THEN-ELSE-ENDIF.  (RWC, WRB)
C***END PROLOGUE  ISORT
C     .. SCALAR ARGUMENTS ..
      INTEGER KFLAG, N
C     .. ARRAY ARGUMENTS ..
      INTEGER IX(*), IY(*)
C     .. LOCAL SCALARS ..
      REAL R
      INTEGER I, IJ, J, K, KK, L, M, NN, T, TT, TTY, TY
C     .. LOCAL ARRAYS ..
      INTEGER IL(21), IU(21)
C     .. EXTERNAL SUBROUTINES ..
C      EXTERNAL XERMSG
C     .. INTRINSIC FUNCTIONS ..
      INTRINSIC ABS, INT

C***FIRST EXECUTABLE STATEMENT  ISORT
      NN = N
      IF (NN.LT.1) THEN
        WRITE(*,*) 'THE NUMBER OF VALUES TO BE SORTED IS NOT POSITIVE.'
        STOP
      ENDIF
C
      KK = ABS(KFLAG)
      IF (KK.NE.1 .AND. KK.NE.2) THEN
        WRITE(*,*) 'THE SORT CONTROL PARAMETER, K, IS INVALID.'
        STOP
      ENDIF
C
C  ALTER ARRAY IX TO GET DECREASING ORDER IF NEEDED
C
      IF (KFLAG.LE.-1) THEN
        DO 10 I=1,NN
          IX(I) = -IX(I)
   10   CONTINUE
      ENDIF
C
      IF (KK.EQ.2) GOTO 100
C
C  SORT IX ONLY
C
      M = 1
      I = 1
      J = NN
      R = 0.375E0
C
   20 IF (I.EQ.J) GOTO 60
      IF (R.LE.0.5898437E0) THEN
        R = R+3.90625E-2
      ELSE
        R = R-0.21875E0
      ENDIF
C
   30 K = I
C
C  SELECT A CENTRAL ELEMENT OF THE ARRAY AND SAVE IT IN LOCATION T
C
      IJ = I + INT((J-I)*R)
      T = IX(IJ)
C
C  IF FIRST ELEMENT OF ARRAY IS GREATER THAN T, INTERCHANGE WITH T
C
      IF (IX(I).GT.T) THEN
        IX(IJ) = IX(I)
        IX(I) = T
        T = IX(IJ)
      ENDIF
      L = J
C
C  IF LAST ELEMENT OF ARRAY IS LESS THAN THAN T, INTERCHANGE WITH T
C
      IF (IX(J).LT.T) THEN
        IX(IJ) = IX(J)
        IX(J) = T
        T = IX(IJ)
C
C  IF FIRST ELEMENT OF ARRAY IS GREATER THAN T, INTERCHANGE WITH T
C
        IF (IX(I).GT.T) THEN
          IX(IJ) = IX(I)
          IX(I) = T
          T = IX(IJ)
        ENDIF
      ENDIF
C
C  FIND AN ELEMENT IN THE SECOND HALF OF THE ARRAY WHICH IS SMALLER THAN T
C
   40 L = L-1
      IF (IX(L).GT.T) GOTO 40
C
C  FIND AN ELEMENT IN THE FIRST HALF OF THE ARRAY WHICH IS GREATER THAN T
C
   50 K = K+1
      IF (IX(K).LT.T) GOTO 50
C
C  INTERCHANGE THESE ELEMENTS
C
      IF (K.LE.L) THEN
        TT = IX(L)
        IX(L) = IX(K)
        IX(K) = TT
        GOTO 40
      ENDIF
C
C  SAVE UPPER AND LOWER SUBSCRIPTS OF THE ARRAY YET TO BE SORTED
C
      IF (L-I.GT.J-K) THEN
        IL(M) = I
        IU(M) = L
        I = K
        M = M+1
      ELSE
        IL(M) = K
        IU(M) = J
        J = L
        M = M+1
      ENDIF
      GOTO 70
C
C  BEGIN AGAIN ON ANOTHER PORTION OF THE UNSORTED ARRAY
C
   60 M = M-1
      IF (M.EQ.0) GOTO 190
      I = IL(M)
      J = IU(M)
C
   70 IF (J-I.GE.1) GOTO 30
      IF (I.EQ.1) GOTO 20
      I = I-1
C
   80 I = I+1
      IF (I.EQ.J) GOTO 60
      T = IX(I+1)
      IF (IX(I).LE.T) GOTO 80
      K = I
C
   90 IX(K+1) = IX(K)
      K = K-1
      IF (T.LT.IX(K)) GOTO 90
      IX(K+1) = T
      GOTO 80
C
C  SORT IX AND CARRY IY ALONG
C
  100 M = 1
      I = 1
      J = NN
      R = 0.375E0
C
  110 IF (I.EQ.J) GOTO 150
      IF (R.LE.0.5898437E0) THEN
        R = R+3.90625E-2
      ELSE
        R = R-0.21875E0
      ENDIF
C
  120 K = I
C
C  SELECT A CENTRAL ELEMENT OF THE ARRAY AND SAVE IT IN LOCATION T
C
      IJ = I + INT((J-I)*R)
      T = IX(IJ)
      TY = IY(IJ)
C
C  IF FIRST ELEMENT OF ARRAY IS GREATER THAN T, INTERCHANGE WITH T
C
      IF (IX(I).GT.T) THEN
        IX(IJ) = IX(I)
        IX(I) = T
        T = IX(IJ)
        IY(IJ) = IY(I)
        IY(I) = TY
        TY = IY(IJ)
      ENDIF
      L = J
C
C  IF LAST ELEMENT OF ARRAY IS LESS THAN T, INTERCHANGE WITH T
C
      IF (IX(J).LT.T) THEN
        IX(IJ) = IX(J)
        IX(J) = T
        T = IX(IJ)
        IY(IJ) = IY(J)
        IY(J) = TY
        TY = IY(IJ)
C
C  IF FIRST ELEMENT OF ARRAY IS GREATER THAN T, INTERCHANGE WITH T
C
        IF (IX(I).GT.T) THEN
          IX(IJ) = IX(I)
          IX(I) = T
          T = IX(IJ)
          IY(IJ) = IY(I)
          IY(I) = TY
          TY = IY(IJ)
        ENDIF
      ENDIF
C
C  FIND AN ELEMENT IN THE SECOND HALF OF THE ARRAY WHICH IS SMALLER THAN T
C
  130 L = L-1
      IF (IX(L).GT.T) GOTO 130
C
C  FIND AN ELEMENT IN THE FIRST HALF OF THE ARRAY WHICH IS GREATER THAN T
C
  140 K = K+1
      IF (IX(K).LT.T) GOTO 140
C
C  INTERCHANGE THESE ELEMENTS
C
      IF (K.LE.L) THEN
        TT = IX(L)
        IX(L) = IX(K)
        IX(K) = TT
        TTY = IY(L)
        IY(L) = IY(K)
        IY(K) = TTY
        GOTO 130
      ENDIF
C
C  SAVE UPPER AND LOWER SUBSCRIPTS OF THE ARRAY YET TO BE SORTED
C
      IF (L-I.GT.J-K) THEN
        IL(M) = I
        IU(M) = L
        I = K
        M = M+1
      ELSE
        IL(M) = K
        IU(M) = J
        J = L
        M = M+1
      ENDIF
      GOTO 160
C
C  BEGIN AGAIN ON ANOTHER PORTION OF THE UNSORTED ARRAY
C
  150 M = M-1
      IF (M.EQ.0) GOTO 190
      I = IL(M)
      J = IU(M)
C
  160 IF (J-I.GE.1) GOTO 120
      IF (I.EQ.1) GOTO 110
      I = I-1
C
  170 I = I+1
      IF (I.EQ.J) GOTO 150
      T = IX(I+1)
      TY = IY(I+1)
      IF (IX(I).LE.T) GOTO 170
      K = I
C
  180 IX(K+1) = IX(K)
      IY(K+1) = IY(K)
      K = K-1
      IF (T.LT.IX(K)) GOTO 180
      IX(K+1) = T
      IY(K+1) = TY
      GOTO 170
C
C  CLEAN UP
C
  190 IF (KFLAG.LE.-1) THEN
        DO 200 I=1,NN
          IX(I) = -IX(I)
  200   CONTINUE
      ENDIF

      RETURN
      END
