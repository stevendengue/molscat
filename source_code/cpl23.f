      SUBROUTINE CPL23(N,MXLAM,LAM,NSTATE,JSTATE,JSINDX,L,MVALUE,IEX,
     1                 VL,IPRINT,LFIRST)
C  Copyright (C) 2019 J. M. Hutson & C. R. Le Sueur
C  Distributed under the GNU General Public License, version 3
C
C  CS COUPLING MATRIX FOR LINEAR ROTOR-LINEAR ROTOR (ITYPE=23)
C  SEE (FOR EXAMPLE) EQN 18 OF HEIL, GREEN AND KOURI JCP (1978) 68 2562
C
C  SAVES M-INDEPENDENT PARTS USING NEW DYNAMIC STORAGE
C              AND IVLFL IN VERSION '12X' OF MOLSCAT.
C  VERSION 5.  LINEAR XCPL NOW STORED BACKWARDS IN HI LOCS OF X().
C  JAN 93      IVLFL CHECKED BEFORE CALL CPL23 AND IV NO LONGER USED
C              M-INDEPENDENT PARTS (9-J) STORED IROW.GE.ICOL.
C              M-DEPENDENT (3J) PARTS STORED IF MEMORY ALLOWS.
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      SAVE NOMEM,NL12,J12MX,NJ12,NXPM,NLM,IHL,IXEX,IXTJ,IXMX,ISTART,
     1     IFIRST
C
      INTEGER IPRINT
      INTEGER LAM(2),JSTATE(NSTATE,3),JSINDX(2),L(2)
      LOGICAL LODD,NOMEM,LFIRST
      DIMENSION VL(2)
C
C  DYNAMIC STORAGE COMMON BLOCK ...
      COMMON /MEMORY/ MX,IXNEXT,NIPR,IDUMMY,X(1)
C
      DATA SQRTHF /.70710678118654753D0/, Z0 /0.D0/
      DATA PIFCT /2.24483902656458321D-2/
C  STATEMENT FUNCTION DEFINITIONS
      Z(I)=DBLE(I+I+1)
      LODD(I)=I-2*(I/2).NE.0
C
C  INITIALIZE IFIRST IF LFIRST IS SET TO TRUE
      IF (LFIRST) THEN
        IFIRST=-2
        LFIRST=.FALSE.
        NOMEM=.FALSE.
      ENDIF
      XM=MVALUE
C
      PM=PARSGN(MVALUE)
      IF (IFIRST.GT.-2) GOTO 3500

C  FIRST TIME THROUGH EVALUATE MVALUE-INDEPENDENT PARTS OF VL()
C  SET-UP AND CHECK STORAGE ...
      NL12=NSTATE*(NSTATE+1)/2
      IXMX=NL12*MXLAM
      IXEX=IXMX
      IF (IEX.GT.0) IXMX=2*IXMX
      NAVAIL=MX-IXNEXT+1
      IF (IXMX.LE.NAVAIL) GOTO 3010

      WRITE(6,601) NSTATE,MXLAM,IEX,IXMX,NAVAIL
  601 FORMAT(/' ***** MCGCPL (JAN 93) NSTATE,MXLAM,IEX =',3I4
     1       /'       REQUIRED STORAGE MORE THAN AVAILABLE',2I9)
      STOP
C
C  SET ISTART SO THAT X(ISTART-IX) IS XCPL(IX), REDUCE MX,
C  AND SET-UP THE NINEJ PARTS IN X().
 3010 ISTART=MX+1
      MX=MX-IXMX
      DO 3100 LL=1,MXLAM
        LM1=LAM(3*LL-2)
        LM2=LAM(3*LL-1)
        LM=LAM(3*LL)
        IL12=0
      DO 3100 I1=1,NSTATE
        J1 =JSTATE(I1,1)
        J2 =JSTATE(I1,2)
        J12=JSTATE(I1,3)
      DO 3100 I2=1,I1
        IL12=IL12+1
        J1P =JSTATE(I2,1)
        J2P =JSTATE(I2,2)
        J12P=JSTATE(I2,3)
        FACTOR=PIFCT*Z(LM)*SQRT(Z(J12)*Z(J12P)*Z(J1)*Z(J1P)*Z(J2)*Z(J2P)
     1                         *Z(LM1)*Z(LM2))*PARSGN(J1+J2+J12)
        IX=(LL-1)*NL12+IL12
        X(ISTART-IX)=FACTOR*THREEJ(J1,LM1,J1P)*THREEJ(J2,LM2,J2P)*
     1                      XNINEJ(J12P,J2P,J1P,J12,J2,J1,LM,LM2,LM1)
        IF (IEX.EQ.0) GOTO 3100
        IF (J1.EQ.J2) THEN
          X(ISTART-IXEX-IX)=X(ISTART-IX)
        ELSE
          X(ISTART-IXEX-IX)=THREEJ(J2,LM1,J1P)*THREEJ(J1,LM2,J2P)*
     1                 XNINEJ(J12P,J2P,J1P,J12,J1,J2,LM,LM2,LM1)*FACTOR
        ENDIF
 3100 CONTINUE

      IF (IPRINT.GE.4) WRITE(6,691) IXMX,NAVAIL
  691 FORMAT(/'  CPL23 (JAN 93).   9-J PARTS STORED.  USED, AVAILABLE=',
     1       2I9)
C  RESET IFIRST TO INDICATE THAT NINE-J PARTS ARE STORED
      IFIRST=-1
C  NOW CALCULATE PARMS NEEDED TO STORE M-DEPENDENT (THRJ) PARTS.
      IXTJ=IXMX
      J12MX=0
      DO 3002 I=1,NSTATE
 3002   J12MX=MAX(J12MX,JSTATE(I,3))
      NJ12=(J12MX+1)*(J12MX+2)/2
      LMAX=0
      IHL=2
      DO 3003 I=1,MXLAM
        IF (LODD(LAM(3*I))) IHL=1
 3003   LMAX=MAX(LMAX,LAM(3*I))
      NLM=LMAX/IHL+1
      NXPM=NJ12*NLM
C
C  SEE IF REQUIRED M-DEPENDENT VALUES (THRJ) ARE STORED.
C  IF NOT, TRY TO STORE THEM IN XCPL().
 3500 MVABS=ABS(MVALUE)
      IF (MVABS.LE.IFIRST .OR. NOMEM) GOTO 3900

      MV=IFIRST+1
C  FIRST CHECK THAT WE STILL HAVE A CONTINUOUS BLOCK OF HI MEMORY.
 3600 IF (MX.EQ.ISTART-IXMX-1) GOTO 3610

      IF (IPRINT.GE.1) WRITE(6,602) MV,ISTART-1,MX,IXMX
  602 FORMAT(/'  CPL23 (JAN 93).   HIGH MEMORY FRAGMENTED.  CANNOT',
     1       ' STORE 3-J VALUES FOR MVAL =',I3/ 19X,
     2       'ORIGINAL MINUS CURRENT MEMORY LIMITS .NE. NO. USED =',
     3       3I12)
      NOMEM=.TRUE.
      GOTO 3900
C  TEST FOR AVAILABLE STORAGE; NEED NXPM FOR THIS MVAL
 3610 NAVAIL=MX-IXNEXT+1
      IF (NXPM.LE.NAVAIL) GOTO 3601

      IF (IPRINT.GE.3) WRITE(6,692) MVABS,NXPM,NAVAIL
  692 FORMAT(/'  CPL23 (JAN 93).   UNABLE TO STORE 3-J VALUES FOR ',
     1        'MVAL =',I3/
     2        '                    REQUIRED AND AVAILABLE STORAGE =',
     3        2I9)
C  SET NOMEM TO REFLECT INABILITY TO ADD MORE M-VALUES
      NOMEM=.TRUE.
      GOTO 3900

C  UPDATE MEMORY POINTERS AND STORE 3-J VALUES FOR THIS MVAL
 3601 IXMX=IXMX+NXPM
      MX=MX-NXPM
      XMV=MV
      LL=0
      DO 3200 IL=1,NLM
        XLM=LL
        IXJ12=0
        DO 3201 J12=0,J12MX
          XJ12=J12
        DO 3201 J12P=0,J12
          XJ12P=J12P
          IXJ12=IXJ12+1
          IX=MV*NXPM+(IL-1)*NJ12+IXJ12
 3201     X(ISTART-IXTJ-IX)=THRJ(XJ12,XLM,XJ12P,XMV,Z0,-XMV)
 3200   LL=LL+IHL
      IF (IPRINT.GE.4) WRITE(6,693) MV,NXPM,NAVAIL
  693 FORMAT(/'  CPL23 (JAN 93).   3-J VALUES STORED FOR MVAL =',I3
     1       /'                    REQUIRED AND AVAILABLE STORAGE =',
     2       2I9)
C  RESET IFIRST TO REFLECT HIGHEST M-VALUE STORED.
      IFIRST=MV
C  SEE IF CURRENT MVALUE REQUIRES MORE STORED M-VALUES.
      MV=MV+1
      IF (MV.LE.MVABS) GOTO 3600
C
C  FILL VL() FROM XCPL
 3900 NZERO=0
      DO 3513 LL=1,MXLAM
        NNZ=0
        I=LL
        LM=LAM(3*LL)
        XLM=LM
        IL=LM/IHL+1
        DO 3503 ICOL=1,N
          I1=JSINDX(ICOL)
          J1 =JSTATE(I1,1)
          J2 =JSTATE(I1,2)
          J12=JSTATE(I1,3)
          XJ12=J12
        DO 3503 IROW=1,ICOL
          I2=JSINDX(IROW)
          J1P =JSTATE(I2,1)
          J2P =JSTATE(I2,2)
          J12P=JSTATE(I2,3)
          XJ12P=J12P
C  FIRST GET THRJ(J12,LM,J12P,M,0,-M) -- EITHER CALC OR FROM STORAG
          IF (MVABS.GT.IFIRST) THEN
            TJM=THRJ(XJ12,XLM,XJ12P,XM,Z0,-XM)*PM
          ELSE
C  NB WE HAVE STORED ON J.GE.J'; (J,L,J'/M,0,-M)=(J',L,J/M,0,-M)
C  ALSO, (J,L,J'/-M,0,M)=PARSGN(J+L+J')*(J,L,J'/M,0,-M)
            IF (J12.GE.J12P) THEN
              IXJ12=J12*(J12+1)/2+J12P+1
            ELSE
              IXJ12=J12P*(J12P+1)/2+J12+1
            ENDIF
            IXM=MVABS*NXPM+(IL-1)*NJ12+IXJ12
            TJM=X(ISTART-IXTJ-IXM)*PM
            IF (MVALUE.LT.0 .AND. LODD(J12+J12P+LM)) TJM=-TJM
          ENDIF
C  THEN GET NINEJ() PARTS
          IF (I1.GE.I2) THEN
            IL12=I1*(I1-1)/2+I2
          ELSE
            IL12=I2*(I2-1)/2+I1
          ENDIF
          IX=(LL-1)*NL12+IL12
          VL(I)=X(ISTART-IX)*TJM
          IF (IEX.EQ.0) GOTO 3593

C *** CODE BELOW ASSUMES THAT SYMMETRICALLY RELATED TERMS ARE BOTH
C *** PRESENT IN POTENTIAL.
          IF (J1.NE.J2) GOTO 3594

          T=VL(I)
          GOTO 3595

 3594     T=X(ISTART-IXEX-IX)*TJM
 3595     VL(I)=VL(I)+PARSGN(IEX+J1+J2-J12+L(ICOL))*T
          IF (J1.EQ.J2)   VL(I)=VL(I)*SQRTHF
          IF (J1P.EQ.J2P) VL(I)=VL(I)*SQRTHF
 3593     IF (VL(I).NE.0.D0) NNZ=NNZ+1
 3503     I=I+MXLAM
        IF (NNZ.LE.0) THEN
          NZERO=NZERO+1
          IF (IPRINT.GE.14) WRITE(6,612) MVALUE,LL
        ENDIF
  612   FORMAT('  * * * NOTE.  FOR MVALUE =',I4,',  ALL COUPLING '
     1         'COEFFICIENTS ARE 0.0 FOR EXPANSION TERM',I4)
 3513 CONTINUE

      IF (NZERO.GT.0 .AND. IPRINT.GE.10 .AND. IPRINT.LT.14)
     1  WRITE(6,620) MVALUE,NZERO
  620 FORMAT('  * * * NOTE.  FOR MVALUE =',I4,',  ALL COUPLING ',
     1       'COEFFICIENTS ARE 0.0 FOR',I5,' POTENTIAL EXPANSION TERMS')

      RETURN
C
      END
